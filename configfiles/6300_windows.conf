# Author: Justin Henderson
# SANS Instructor and author of SANS SEC555: SIEM and Tactical Analytics
# Email: justin@hasecuritysolutions.com
# Last Update: 11/19/2017

filter {
  if "windows_log" in [tags] {
    if "nxlog" in [tags] {
      date {
        match => ["EventTime", "YYYY-MM-dd HH:mm:ss"]
        remove_field => [ "EventTime" ]
      }
    }

    mutate {
      rename => [ "AccountName", "user" ]
      rename => [ "AccountType", "account_type" ]
      rename => [ "ActivityID", "activity_id" ]
      rename => [ "Category", "category" ]
      rename => [ "ClientAddress", "client_ip" ]
      rename => [ "Channel", "channel" ]
      rename => [ "command_line", "command_line" ]
      rename => [ "DCIPAddress", "domain_controller_ip" ]
      rename => [ "DCName", "domain_controller_name" ]
      rename => [ "DestAddress", "destination_ip" ]
      rename => [ "DestinationIp", "windows_destination_ip"]
      rename => [ "DestPort", "destination_port" ]
      rename => [ "EventReceivedTime", "event_received_time" ]
      rename => [ "EventType", "event_type" ]
      rename => [ "GatewayIPAddress", "gateway_ip" ]
      rename => [ "IPAddress", "source_ip" ]
      rename => [ "Ipaddress", "source__ip" ]
      rename => [ "IpAddress", "source_ip" ]
      rename => [ "IPPort", "source_port" ]
      rename => [ "OpcodeValue", "opcode_value" ]
      rename => [ "PreAuthType", "preauthentication_type" ]
      rename => [ "PrincipleSAMName", "user" ]
      rename => [ "ProcessID", "process_id" ]
      rename => [ "ProviderGUID", "providerguid" ]
      rename => [ "RecordNumber", "record_number" ]
      rename => [ "RemoteAddress", "destination_ip" ]
      rename => [ "ServiceName", "service_name" ]
      rename => [ "ServiceID", "service_id" ]
      rename => [ "SeverityValue", "severity_value" ]
      rename => [ "SourceAddress", "source_ip" ]
      rename => [ "SourceIP", "windows_source_ip" ]
      rename => [ "SourcePort", "source_port" ]
      rename => [ "SourceModuleName", "source_module_name" ]
      rename => [ "SourceModuleType", "source_module_type" ]
      rename => [ "SourceName", "source_name" ]
      rename => [ "SubjectUserName", "user" ]
      rename => [ "TaskName", "task_name" ]
      rename => [ "TargetDomainName", "target_domain_name" ]
      rename => [ "TargetUserName", "user" ]
      rename => [ "ThreadID", "thread_id" ]
      rename => [ "[event_data][CommandLine]", "command_line" ]
      rename => [ "[event_date][ContextInfo]", "context_info" ]
      rename => [ "[event_data][CurrentDirectory]", "current_directory" ]
      rename => [ "[event_data][DestAddress]", "destination_ip" ]
      rename => [ "[event_data][DestPort]", "destination_port" ]
      rename => [ "[event_data][Hashes]", "hashes" ]
      rename => [ "[event_data][Image]", "image" ]
      rename => [ "[event_data][IntegrityLevel]", "integrity_level" ]
      rename => [ "[event_data][ParentCommandLine]", "parent_command_line" ]
      rename => [ "[event_data][ParentImage]", "parent_image" ]
      rename => [ "[event_data][Payload]", "payload" ]
      rename => [ "[event_data][SourceAddress]", "source_ip" ]
      rename => [ "[event_data][SourcePort]", "source_port" ]
      rename => [ "[event_data][ScriptBlockText]", "script_block_text" ]
      rename => [ "[event_data][TargetUserName]", "user"]
      rename => [ "[event_data][user][name]", "user"]
      rename => [ "[event_data][user][identifier]", "user_sid"]
      rename => [ "[event_data][user][type]", "user_type"]
      rename => [ "[event_data][user][domain]", "user_domain"]
      rename => [ "[user][name]", "user"]
      rename => [ "[user][identifier]", "user_sid"]
      rename => [ "[user][type]", "user_type"]
      rename => [ "[user][domain]", "user_domain"]
    }
    mutate {
      convert => [ "command_line_length", "integer" ]
      convert => [ "destination_port", "integer" ]
      convert => [ "source_port", "integer" ]
      convert => [ "user", "string" ]
    }
    if [user] == "-" {
      mutate { remove_field => [ "user" ] }
    }
    if [user] {
      ruby {
        code => 'case event.get("[user]")
                   when Hash
                     event.tag("empty_user")
                   when Array
                     event.tag("empty_user")
                   end'
      }
    }
    if "empty_user" in [tags] {
      mutate { remove_field => [ "user" ] }
    }
    if [source_ip] == "-" {
      mutate { remove_field => [ "source_ip" ] }
    }
    if [Application] {
      grok {
        match => { "Application" => "\\device\\harddiskvolume%{INT}\\%{GREEDYDATA:ApplicationPath}" }
      }
      if [ApplicationPath] {
        mutate {
          add_field => { "ApplicationPathIgnoringx86" => "%{ApplicationPath}" }
        }
        mutate {
          gsub => [ "ApplicationPathIgnoringx86", "program files (x86)", "program files" ]
        }
      }
    }
    if [event_id] == 4634 {
      mutate {
        add_tag => [ "logoff" ]
      }
    }
    if [event_id] == 4624 or [event_id] == 528 or [event_id] == 540 or [event_id] == 552 or [event_id] == 682 or [event_id] == 4648 or [event_id] == 4778 {
      mutate {
        add_tag => [ "logon" ]
        add_tag => [ "alert_data" ]
      }
    }
    if [event_id] == 529 or [event_id] == 4625 or [event_id] == 530 or [event_id] == 531 or [event_id] == 532 or [event_id] == 533 or [event_id] == 534 or [event_id] == 535 or [event_id] == 536 or [event_id] == 536 or [event_id] == 537 or [event_id] == 538 or [event_id] == 539 or [event_id] == 4625 or [event_id] == 4771 {
      mutate {
        add_tag => [ "logon_failure" ]
        add_tag => [ "alert_data" ]
      }
    }
    # Criticl event IDs to monitor
    if [event_id] == 7030 or [event_id] == 4720 or [event_id] == 4722 or [event_id] == 4724 or [event_id] == 4738 or [event_id] == 4732 or [event_id] == 1102 or [event_id] == 1056 or [event_id] == 2003 or [event_id] == 2005 or [event_id] == 8003 or [event_id] == 8004 or [event_id] == 8006 or [event_id] == 8007 {
      mutate {
        add_tag => [ "alert_data" ]
      }
    }
    if [command_line] {
      ruby {
        code => "event.set('command_line_length', event.get('command_line').length)"
      }
      grok {
        match => { "command_line" => "(?<possible_base64_code>[A-Za-z0-9+/]{50,}[=]{0,2})" }
        tag_on_failure => []
      }
    }
    # Ignore broadcasts received by Sysmon
    if [event_id] == 3 and [SourceIp] =~ "255$" { drop {} }
    if [event_id] == 3 and [DestinationIp] =~ "255$" { drop {} }

    if [source_name] == "Microsoft-Windows-AppLocker" {
      #grok {
      #  match => { "UserData" => "%{DATA}>%{DATA:xml}</RuleAndFileData>" }
      #}
      xml {
        source => "UserData"
        target => "applocker"
      }
      mutate {
        rename => [ "[applocker][FileHash]", "filehash" ]
        rename => [ "[applocker][FilePath]", "filepath" ]
        rename => [ "[applocker][Fqbn]", "fqbn" ]
        rename => [ "[applocker][PolicyName]", "policyname" ]
        rename => [ "[applocker][RuleId]", "ruleid" ]
        rename => [ "[applocker][RuleName]", "rulename" ]
        rename => [ "[applocker][RuleSddl]", "rulesddl" ]
        rename => [ "[applocker][TargetProcessId]", "targetprocessid" ]
        rename => [ "[applocker][TargetUser]", "user_sid" ]
      }
      if [event_id] == 8002 or [event_id] == 8005 {
        mutate {
          add_field =>  { "action" => "allow" } 
        }
      }
      if [event_id] == 8004 or [event_id] == 8007 {
        mutate {
          add_field =>  { "action" => "deny" } 
        }
      }
      if [event_id] == 8006 or [event_id] == 8003 {
        mutate {
          add_field =>  { "action" => "audit_deny" } 
        }
      }
      grok {
        match => { "Message" => "%{DATA:file} was allowed to run" }
        match => { "Message" => "%{DATA:file} was not allowed to run" }
        match => { "Message" => "%{DATA:file} was prevented from running" }
      }
      grok {
        match => { "file" => "\%%{DATA}\%%{GREEDYDATA:file_query}" }
      }
      if [file_query] {
        # Backslashes are odd to handle so convert to quad slash with single quotes and then remove single quotes
        mutate {
           gsub => [ "file_query", "[\\]", "'\\\\'" ]
        }
        mutate {
          gsub => [ "file_query", "'", "" ]
        }
        # Sleep for half a second to give correlation alert time to arrive first
        sleep {
          time => "0.5"
        }
        # Optional settings
        #elasticsearch {
        #  hosts => ["elasticsearch_server_name_goes_here"]
        #  index => "logstash-windows-*"
        #  query => "source_name:Microsoft-Windows-Sysmon AND event_id:7 AND Image:%{[file_query]}"
        #  fields => [["@timestamp","match_date"],["Hashes","hashes"],["Signed","signed"],["Signature","signature"],["SignatureStatus","signature_status"],["ProcessId","process_id"]]
        #}
        mutate {
          remove_field => [ "file_query" ]
        }
      }
    }
    if [event_id] == 4103 and [source_name] == "Microsoft-Windows-PowerShell" {
      grok {
        match => { "context_info" => "\s+Severity = %{DATA:severity}\s+Host Name = %{DATA:shell_host_name}\s+Host Version = %{DATA:shell_host_version}\s+Host ID = %{DATA:shell_host_id}\s+Host Application = %{DATA:shell_host_application}\s+Engine Version = %{DATA:shell_engine_version}\s+Runspace ID = %{DATA:runspace_id}\s+Pipeline ID = %{INT:pipeline_id}\s+Command Name = %{DATA:command_name}\s+Command Type = %{DATA:command_type}\s+Script Name = %{DATA:Path}\s+Command Path = %{DATA:command_path}\s+Sequence Number = %{INT:sequence_number}\s+User = %{DATA:shell_user}\s+Connected User = %{DATA:connected_user}\s+Shell ID = %{GREEDYDATA:shell_id}" }
      }
      if [shell_host_application] {
        grok {
          match => { "shell_host_application" => "(?<possible_base64_code>[A-Za-z0-9+/]{50,}[=]{0,2})" }
          tag_on_failure => []
        }
        ruby {
          code => "event.set('shell_host_application_length', event.get('shell_host_application').length)"
        }
        mutate {
          convert => [ "shell_host_application_length", "integer" ]
        }
      }
    }
    if [event_id] == 4104 and [script_block_text] and [source_name] == "Microsoft-Windows-PowerShell" {
      grok {
          match => { "script_block_text" => "(?<possible_base64_code>[A-Za-z0-9+/]{50,}[=]{0,2})" }
          tag_on_failure => []
        }
        ruby {
          code => "event.set('script_block_text_length', event.get('script_block_text').length)"
        }
        mutate {
          convert => [ "script_block_text_length", "integer" ]
        }
    }
    if [possible_base64_code] {
      mutate {
        add_tag => [ "possible_base64_encoding" ]
      }
      ruby {
        init => "require 'base64'"
        code => "a = Base64.decode64(event.get('possible_base64_code'));
                 #a = a.force_encoding('ASCII-8BIT').encode('UTF-8', :invalid => :replace, :undef => :replace, :replace => '');
                 event.set('base64_decoded', a);"
                 #if a.include? 'iex'
                 #  event.set('iex','true')
                 #end;"
      }
    }
    if [payload] and [event_id] == 4103 and [source_name] == "Microsoft-Windows-PowerShell" {
      ruby {
        code => "event.set('cmdlets', event.get('payload').downcase.scan(/commandinvocation\(([a-z0-9-]+)\)/))"
      }
    }
    if [command_line] {
      if [command_line] =~ "iex" or [command_line] =~ "Invoke-Expression" {
        mutate {
          add_tag => [ "ps_iex" ]
        }
      }
      if [command_line] =~ "New-Object" and [command_line] =~ "Net.WebClient" {
        mutate {
          add_tag => [ "ps_webclient" ]
        }
      }
    }
    if [script_block_text] {
      if [script_block_text] =~ "iex" or [script_block_text] =~ "Invoke-Expression" {
        mutate {
          add_tag => [ "ps_iex" ]
        }
      }
      if [script_block_text] =~ "New-Object" and [script_block_text] =~ "Net.WebClient" {
        mutate {
          add_tag => [ "ps_webclient" ]
        }
      }
    }
   
   if "ps_iex" not in [tags] and [base64_decoded] {
      mutate { add_tag => [ "test" ]  }
      grok {
        match => { "base64_decoded" => "(?<iex>iex)" }
      }
      if [base64_decoded] =~ "iex" or [base64_decoded] =~ "Invoke-Expression" {
        mutate { add_tag => [ "test2" ] }
        mutate {
          add_tag => [ "ps_iex" ]
        }
      }
    }
    if "ps_webclient" not in [tags] and [base64_decoded] {
      if [base64_decoded] =~ "New-Object" and [base64_decoded] =~ "Net.WebClient" {
        mutate {
          add_tag => [ "ps_webclient" ]
        }

      }
    }
   
   if "ps_iex" not in [tags] and [base64_decoded] {
      mutate { add_tag => [ "test" ]  }
      grok {
        match => { "base64_decoded" => "(?<iex>iex)" }
      }
      if [base64_decoded] =~ "iex" or [base64_decoded] =~ "Invoke-Expression" {
        mutate { add_tag => [ "test2" ] }
        mutate {
          add_tag => [ "ps_iex" ]
        }
      }
    }
    if "ps_webclient" not in [tags] and [base64_decoded] {
      if [base64_decoded] =~ "New-Object" and [base64_decoded] =~ "Net.WebClient" {
        mutate {
          add_tag => [ "ps_webclient" ]
        }
      }
    }
    if "ps_webclient" in [tags] and "ps_iex" in [tags] {
      mutate {
        add_tag => [ "alert_data", "ps_possible_web_code_use" ]
      }
    }
    # For any accounts that are service accounts or special accounts add the tag of service_account
    # This example applies the tag to any username that starts with SVC_.  If you use a different
    # standard change this.
    if [user] =~ "^DWM-*" or [user] == "SYSTEM" or [user] == "NETWORK SERVICE" or [user] == "LOCAL SERVICE" or [user] =~ "^SVC_*" {
      mutate {
        add_tag => [ "service_account" ]
      }
    }
    #Identify machine accounts
    if [user] =~ /\$/ {
      mutate {
        add_tag => [ "machine", "noise" ]
      }
    }
  }
}
